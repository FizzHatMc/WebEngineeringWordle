<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Wordle</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.js"></script>
</head>
<body class="bg-gray-900 text-gray-50">
<h1 class="text-3xl font-bold mb-4">Multiplayer Wordle</h1>
<div id="game-container">
    <div id="board"></div>
    <div id="input-container">
        <input type="text" id="text-input" placeholder="Enter your guess" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        <button id="submit-button" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">Submit</button>
    </div>
    <div id="players-container">
        <h2>Players</h2>
        <ul id="player-list">
        </ul>
    </div>
    <div id="message-container"></div>
    <div id="game-over-modal">
        <div id="game-over-content">
            <h2 id="game-over-title"></h2>
            <p id="game-over-message"></p>
            <button id="new-game-button">New Game</button>
        </div>
    </div>
    <div id="submitted-words">
        <h2>Submitted Words</h2>
        <ul id="word-list">
        </ul>
    </div>
</div>
<script>
    const gameId = new URLSearchParams(window.location.search).get('id');
const port = new URLSearchParams(window.location.search).get('port');
const playerName = new URLSearchParams(window.location.search).get('name'); // Get player name
const socket = io(`http://localhost:${port}/?id=${gameId}`); // Connect to the sub-server

const boardElement = document.getElementById('board');
const textInput = document.getElementById('text-input');
const submitButton = document.getElementById('submit-button');
const messageContainer = document.getElementById('message-container');
const gameOverModal = document.getElementById('game-over-modal');
const gameOverTitle = document.getElementById('game-over-title');
const gameOverMessage = document.getElementById('game-over-message');
const newGameButton = document.getElementById('new-game-button');
const playerListElement = document.getElementById('player-list');
const wordListElement = document.getElementById('word-list');

const MAX_GUESSES = 6;
const WORD_LENGTH = 5;

let board = []; // This will now be an array of strings
let currentRow = 0;
let currentGuess = ''; // This will hold the current word being typed
let solutionWord = ''; // Renamed 'word' to 'solutionWord' to avoid confusion

let isGameOver = false;
let playerId = '';
let players = [];
let submittedWords = [];

function createBoard() {
    board = [];
    for (let i = 0; i < MAX_GUESSES; i++) {
        board.push('');
    }
    board[currentRow] = currentGuess;
}

function renderBoard() {
    console.log("Current board state:", board);
    boardElement.innerHTML = ''; // Clear the board

    if (!board || !Array.isArray(board)) {
        console.error("Board is not defined or is not an array:", board);
        return;
    }

    board.forEach((word, wordIndex) => { // 'word' is now correctly a string
        // Ensure the word is at least an empty string to prevent errors
        if (typeof word !== 'string') {
            console.error("Board element is not a string:", word, "Word Index:", wordIndex);
            word = ''; // Default to empty string to continue rendering
        }

        // Pad the word with empty spaces if it's shorter than WORD_LENGTH for display
        // This ensures all 5 tiles are always rendered for each row
        const displayWord = word.padEnd(WORD_LENGTH, ' ');

        for (let letterIndex = 0; letterIndex < WORD_LENGTH; letterIndex++) {
            const letter = displayWord[letterIndex];

            const tile = document.createElement('div');
            tile.className = 'tile';
            const tileInner = document.createElement('div');
            tileInner.className = 'tile-inner';
            tileInner.textContent = letter.trim(); // Trim to not show spaces in tiles

            // Apply styling only for words that have been submitted (past rows)
            // Or for the current row if it's a submitted word from another player
            // The current player's *active typing* is handled by textInput.value
            // This logic is a bit tricky with multiplayer.
            // We apply styling if the word is fully submitted OR it's a past row.
            // For the current row, we only apply styling if the word has been
            // submitted (i.e., its length is WORD_LENGTH) AND it's not the current player's
            // active typing (handled by the input field itself).
            // A simpler approach for the client is to only style fully submitted words (wordIndex < currentRow).
            // The current input is reflected in the text input, not necessarily on the board tiles yet.

            // Refined styling logic for renderBoard:
            // Only apply styling to rows that are 'locked in' (i.e., submitted)
            // This means words from `board` that are fully entered and are not the 'current' active row
            // Or if it's the current row, but it's a complete word (from another player's guess)
            const isSubmittedWord = (word.length === WORD_LENGTH && wordIndex < currentRow);
            const isCurrentPlayerTypingRow = (wordIndex === currentRow && currentGuess.length < WORD_LENGTH);


            // This is where we need the actual solution word to determine correct/present/absent.
            // The `solutionWord` is only available when `game-start` is emitted.
            // This `renderBoard` function needs `solutionWord` to be set globally or passed in.
            if (solutionWord && (isSubmittedWord || (wordIndex === currentRow && word.length === WORD_LENGTH))) {
                const letterUpper = letter.toUpperCase();
                const solutionUpper = solutionWord.toUpperCase();

                if (letterUpper === solutionUpper[letterIndex]) {
                    tile.classList.add('correct');
                } else if (solutionUpper.includes(letterUpper)) {
                    // This 'present' logic needs refinement for strict Wordle rules
                    // (counting occurrences of letters in solution to avoid over-marking)
                    // For a basic implementation, this is often sufficient.
                    tile.classList.add('present');
                } else {
                    tile.classList.add('absent');
                }
            } else if (isCurrentPlayerTypingRow && currentRow === wordIndex) {
                // For the row the current player is typing in, don't apply colors yet
                // Only show the letters they have typed. This is implicitly handled by textContent.
                // If you want to show empty boxes for untyped letters in the current row:
                // The padding ' ' above handles this.
            }

            tile.appendChild(tileInner);
            boardElement.appendChild(tile);
        }
    });
}

// This function will be called on keyup/input to update the local board state
// before a guess is submitted to the server.
function updateCurrentGuessDisplay() {
    currentGuess = textInput.value.toUpperCase();
    // Ensure the board array has enough elements for the current row
    if (board.length <= currentRow) {
        // This case should ideally not happen if createBoard initializes correctly
        // or if updateBoard from server always sets enough rows.
        // But as a fallback, ensure the row exists.
        while (board.length <= currentRow) {
            board.push('');
        }
    }
    board[currentRow] = currentGuess;
    renderBoard(); // Re-render the board with the current partial guess
}


function handleGuessSubmit() {
    if (isGameOver) return;

    const guess = textInput.value.trim();
    if (guess.length === WORD_LENGTH) {
        // Before sending, ensure the board is updated with the final current guess
        // This is effectively "locking in" the currentGuess into the board state
        board[currentRow] = guess.toUpperCase();
        socket.emit('guess', { gameId, guess, playerName }); // Send guess and player name
        textInput.value = ''; // Clear input after submission
        currentGuess = ''; // Clear currentGuess after submission
        // We don't increment currentRow here. The server will tell us the new currentRow.
    } else {
        showMessage('Not enough letters!');
    }
}

function showMessage(message) {
    const messageElement = messageContainer;
    messageElement.textContent = message;
    messageElement.classList.add('show-message');
    setTimeout(() => {
        messageElement.classList.remove('show-message');
    }, 3000);
}

// updateBoard now expects a 1D array of strings
function updateBoard(newBoard) {
    board = newBoard; // Directly replace the board with the server's state
    // When the server sends an update, it represents the full history of guesses
    // So we need to re-evaluate the currentRow based on the received board
    currentRow = newBoard.length; // The next guess will go to the end of this array
    // We also need to make sure 'board' has enough empty rows for future guesses
    while (board.length < MAX_GUESSES) {
        board.push(''); // Add empty strings for remaining guess slots
    }
    renderBoard();
}

function displayGameOver(isWin, word) {
    isGameOver = true;
    gameOverTitle.textContent = isWin ? 'Congratulations!' : 'Game Over!';
    gameOverMessage.textContent = isWin
        ? 'You guessed the word!'
        : `The word was ${word.toUpperCase()}. Better luck next time!`;
    gameOverModal.classList.add('show');
}

function resetGame() {
    createBoard(); // Reset board to empty strings
    currentRow = 0;
    currentGuess = '';
    isGameOver = false;
    gameOverModal.classList.remove('show');
    socket.emit('new-game', { gameId, playerName }); // Emit new-game event with playerName
    submittedWords = [];
    wordListElement.innerHTML = '';
    renderBoard(); // Ensure the board is rendered when resetting.
}

function updateSubmittedWords(newWord, playerName) {
    submittedWords.push({ word: newWord, player: playerName });
    const li = document.createElement('li');
    li.textContent = `${playerName}: ${newWord.toUpperCase()}`; // Display "Name: Word" in uppercase
    wordListElement.appendChild(li);
    wordListElement.scrollTop = wordListElement.scrollHeight; // Scroll to bottom
}

newGameButton.addEventListener('click', resetGame);
submitButton.addEventListener('click', handleGuessSubmit);
textInput.addEventListener('input', updateCurrentGuessDisplay); // Listen for input changes

socket.on('connect', () => {
    playerId = socket.id;
    socket.emit('join-game', { gameId, playerName }); // Send player name on join
});

socket.on('game-start', (data) => {
    solutionWord = data.word; // Set the solution word
    createBoard(); // Initialize the board with empty strings
    renderBoard(); // Render the empty board
    if (data.players) {
        players = data.players;
        updatePlayerList(data.players);
    }
    // If there are already guesses (e.g., player joined mid-game), update board
    if (data.board) {
        updateBoard(data.board);
    }
});

socket.on('update-board', (data) => {
    if (data && data.board && Array.isArray(data.board)) {
        // Update the board with the server's full state of guesses
        updateBoard(data.board);

        // Logic to add the last submitted word to the submittedWords list
        // The server sends the *entire* board state, so the last guess
        // is the last element in data.board.
        if (data.board.length > 0) {
            const lastGuessedWord = data.board[data.board.length - 1]; // Get the last submitted word
            const emittingPlayerName = data.playerName; // The server needs to send this with the update-board event
            updateSubmittedWords(lastGuessedWord, emittingPlayerName);
        }
    } else {
        console.error("data is undefined, data.board is undefined or not an array:", data);
    }
});

socket.on('game-over', (data) => {
    displayGameOver(data.isWin, data.word);
    isGameOver = true;
});

socket.on('message', (message) => {
    showMessage(message);
});

socket.on('player-list', (updatedPlayers) => {
    players = updatedPlayers;
    updatePlayerList(updatedPlayers);
});

function updatePlayerList(playerList) {
    playerListElement.innerHTML = ''; // Clear the list
    playerList.forEach(player => {
        const li = document.createElement('li');
        li.textContent = player.id === playerId ? `You (${player.name})` : `${player.name}`; // Display "You"
        if (player.id === playerId) {
            li.id = "current-player";
        }
        playerListElement.appendChild(li);
    });
}

// Initial setup
createBoard();
renderBoard();
</script>

</body>
</html>
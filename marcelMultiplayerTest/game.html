<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Wordle</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.js"></script>
    <style>
        /* ... (your existing CSS remains the same) ... */
        body {
            font-family: 'Press Start 2P', monospace;
            background-color: #111827;
            color: #f9fafb;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            overflow-x: hidden; /* Prevent horizontal scrollbar */
        }
        h1 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: #6366f1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            text-align: center; /* Center heading */
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px; /* Increased max-width */
            margin-bottom: 1rem;
        }
        #board {
            display: grid;
            grid-template-rows: repeat(6, 1fr);
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
            width: 100%; /* Make board responsive */
            max-width: 350px; /* Max width for the board */
        }
        .tile {
            width: 100%; /* Make tiles responsive */
            height: 0;
            padding-bottom: 100%; /* Maintain square aspect ratio */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            border: 2px solid #4b5563;
            border-radius: 0.25rem;
            background-color: #1f2937;
            color: #f9fafb;
            text-transform: uppercase;
            transition: background-color 0.3s ease;
            position: relative; /* For absolute positioning of letters */
        }
        .tile-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            text-transform: uppercase;
        }
        .correct {
            background-color: #6ee7b7;
            border-color: #6ee7b7;
            color: #1f2937;
        }
        .present {
            background-color: #fef08a;
            border-color: #fef08a;
            color: #1f2937;
        }
        .absent {
            background-color: #374151;
            border-color: #374151;
            color: #f9fafb;
        }
        #input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            margin-bottom: 1rem;
        }
        #text-input {
            padding: 0.75rem 1rem;
            font-size: 1rem;
            border: 2px solid #4b5563;
            border-radius: 0.25rem;
            background-color: #f3f4f6;
            color: #1f2937;
            width: 100%;
            max-width: 300px;
            margin-bottom: 0.5rem;
        }
        #submit-button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            background-color: #4caf50;
            color: #f9fafb;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
            width: 100%;
            max-width: 300px;
            text-align: center;
        }
        #submit-button:hover {
            background-color: #45a049;
        }
        #message-container {
            position: fixed; /* Fix message container */
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #f9fafb;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            margin-bottom: 1rem;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .show-message {
            opacity: 1;
        }
        #game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #game-over-modal.show {
            opacity: 1;
            visibility: visible;
        }
        #game-over-content {
            background-color: #1f2937;
            padding: 2rem;
            border-radius: 0.25rem;
            text-align: center;
            border: 2px solid #6b7280;
            width: 90%;
            max-width: 400px;
        }
        #game-over-content h2 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: #f9fafb;
        }
        #game-over-content p {
            font-size: 1rem;
            margin-bottom: 1.5rem;
            color: #d1d5db;
        }
        #new-game-button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            background-color: #6b7280;
            color: #f9fafb;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 1rem;
        }
        #new-game-button:hover {
            background-color: #4b5563;
        }
        #players-container {
            margin-top: 1rem;
            text-align: center;
            width: 100%;
        }
        #players-container h2 {
            font-size: 1rem;
            color: #d1d5db;
            margin-bottom: 0.5rem;
        }
        #player-list {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #player-list li {
            background-color: #374151;
            color: #f9fafb;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
        }
        #current-player {
            font-weight: bold;
            color: #6ee7b7;
        }
        #submitted-words {
            margin-top: 2rem;
            padding: 1rem;
            border: 2px solid #4b5563;
            border-radius: 0.25rem;
            background-color: #1f2937;
            color: #f9fafb;
            width: 100%;
            max-width: 400px;
        }
        #submitted-words h2 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        #submitted-words ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #submitted-words li {
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            background-color: #374151;
            margin-bottom: 0.5rem;
            font-size: 1rem;
            text-align: center;
        }
        @media (max-width: 640px) {
            h1 {
                font-size: 1.75rem;
            }
            #board {
                gap: 0.25rem;
                max-width: 320px;
            }
            .tile {
                font-size: 1.25rem;
            }
            .tile-inner {
                font-size: 1.25rem;
            }
            .key {
                font-size: 0.8rem;
            }
            .key-inner{
                font-size: 0.8rem;
            }
            .keyboard-row {
                gap: 0.125rem;
            }
            #message-container {
                font-size: 0.75rem;
                padding: 0.25rem 0.5rem;
            }
            #game-over-content {
                padding: 1.5rem;
            }
            #game-over-content h2 {
                font-size: 1rem;
            }
            #game-over-content p {
                font-size: 0.8rem;
            }
            #new-game-button {
                font-size: 0.9rem;
                padding: 0.5rem 1rem;
            }
            #player-list li {
                font-size: 0.6rem;
                padding: 0.2rem 0.4rem;
            }
            #text-input {
                font-size: 0.9rem;
                padding: 0.6rem;
            }
            #submit-button {
                font-size: 0.9rem;
                padding: 0.75rem 1.5rem;
            }
            #submitted-words {
                font-size: 0.8rem;
                padding: 1rem;
            }
            #submitted-words li {
                font-size: 0.8rem;
                padding: 0.2rem 0.4rem;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-50">
<h1 class="text-3xl font-bold mb-4">Multiplayer Wordle</h1>
<div id="game-container">
    <div id="board"></div>
    <div id="input-container">
        <input type="text" id="text-input" placeholder="Enter your guess" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        <button id="submit-button" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">Submit</button>
    </div>
    <div id="players-container">
        <h2>Players</h2>
        <ul id="player-list">
        </ul>
    </div>
    <div id="message-container"></div>
    <div id="game-over-modal">
        <div id="game-over-content">
            <h2 id="game-over-title"></h2>
            <p id="game-over-message"></p>
            <button id="new-game-button">New Game</button>
        </div>
    </div>
    <div id="submitted-words">
        <h2>Submitted Words</h2>
        <ul id="word-list">
        </ul>
    </div>
</div>
<script>
    const gameId = new URLSearchParams(window.location.search).get('id');
    const port = new URLSearchParams(window.location.search).get('port');
    const playerName = new URLSearchParams(window.location.search).get('name'); // Get player name
    const socket = io(`http://localhost:${port}/?id=${gameId}`); // Connect to the sub-server

    const boardElement = document.getElementById('board');
    const textInput = document.getElementById('text-input');
    const submitButton = document.getElementById('submit-button');
    const messageContainer = document.getElementById('message-container');
    const gameOverModal = document.getElementById('game-over-modal');
    const gameOverTitle = document.getElementById('game-over-title');
    const gameOverMessage = document.getElementById('game-over-message');
    const newGameButton = document.getElementById('new-game-button');
    const playerListElement = document.getElementById('player-list');
    const wordListElement = document.getElementById('word-list');

    const MAX_GUESSES = 6;
    const WORD_LENGTH = 5;

    let board = []; // This will now be an array of strings
    let currentRow = 0;
    let currentGuess = ''; // This will hold the current word being typed
    let solutionWord = ''; // Renamed 'word' to 'solutionWord' to avoid confusion

    let isGameOver = false;
    let playerId = '';
    let players = [];
    let submittedWords = [];

    function createBoard() {
        board = [];
        for (let i = 0; i < MAX_GUESSES; i++) {
            board.push(''); // Initialize each guess slot as an empty string
        }
        // When creating a new board, also ensure the current guess input is correctly placed
        // This is important for when the user types
        board[currentRow] = currentGuess;
    }

    function renderBoard() {
        console.log("Current board state:", board);
        boardElement.innerHTML = ''; // Clear the board

        if (!board || !Array.isArray(board)) {
            console.error("Board is not defined or is not an array:", board);
            return;
        }

        board.forEach((word, wordIndex) => { // 'word' is now correctly a string
            // Ensure the word is at least an empty string to prevent errors
            if (typeof word !== 'string') {
                console.error("Board element is not a string:", word, "Word Index:", wordIndex);
                word = ''; // Default to empty string to continue rendering
            }

            // Pad the word with empty spaces if it's shorter than WORD_LENGTH for display
            // This ensures all 5 tiles are always rendered for each row
            const displayWord = word.padEnd(WORD_LENGTH, ' ');

            for (let letterIndex = 0; letterIndex < WORD_LENGTH; letterIndex++) {
                const letter = displayWord[letterIndex];

                const tile = document.createElement('div');
                tile.className = 'tile';
                const tileInner = document.createElement('div');
                tileInner.className = 'tile-inner';
                tileInner.textContent = letter.trim(); // Trim to not show spaces in tiles

                // Apply styling only for words that have been submitted (past rows)
                // Or for the current row if it's a submitted word from another player
                // The current player's *active typing* is handled by textInput.value
                // This logic is a bit tricky with multiplayer.
                // We apply styling if the word is fully submitted OR it's a past row.
                // For the current row, we only apply styling if the word has been
                // submitted (i.e., its length is WORD_LENGTH) AND it's not the current player's
                // active typing (handled by the input field itself).
                // A simpler approach for the client is to only style fully submitted words (wordIndex < currentRow).
                // The current input is reflected in the text input, not necessarily on the board tiles yet.

                // Refined styling logic for renderBoard:
                // Only apply styling to rows that are 'locked in' (i.e., submitted)
                // This means words from `board` that are fully entered and are not the 'current' active row
                // Or if it's the current row, but it's a complete word (from another player's guess)
                const isSubmittedWord = (word.length === WORD_LENGTH && wordIndex < currentRow);
                const isCurrentPlayerTypingRow = (wordIndex === currentRow && currentGuess.length < WORD_LENGTH);


                // This is where we need the actual solution word to determine correct/present/absent.
                // The `solutionWord` is only available when `game-start` is emitted.
                // This `renderBoard` function needs `solutionWord` to be set globally or passed in.
                if (solutionWord && (isSubmittedWord || (wordIndex === currentRow && word.length === WORD_LENGTH))) {
                    const letterUpper = letter.toUpperCase();
                    const solutionUpper = solutionWord.toUpperCase();

                    if (letterUpper === solutionUpper[letterIndex]) {
                        tile.classList.add('correct');
                    } else if (solutionUpper.includes(letterUpper)) {
                        // This 'present' logic needs refinement for strict Wordle rules
                        // (counting occurrences of letters in solution to avoid over-marking)
                        // For a basic implementation, this is often sufficient.
                        tile.classList.add('present');
                    } else {
                        tile.classList.add('absent');
                    }
                } else if (isCurrentPlayerTypingRow && currentRow === wordIndex) {
                    // For the row the current player is typing in, don't apply colors yet
                    // Only show the letters they have typed. This is implicitly handled by textContent.
                    // If you want to show empty boxes for untyped letters in the current row:
                    // The padding ' ' above handles this.
                }

                tile.appendChild(tileInner);
                boardElement.appendChild(tile);
            }
        });
    }

    // This function will be called on keyup/input to update the local board state
    // before a guess is submitted to the server.
    function updateCurrentGuessDisplay() {
        currentGuess = textInput.value.toUpperCase();
        // Ensure the board array has enough elements for the current row
        if (board.length <= currentRow) {
            // This case should ideally not happen if createBoard initializes correctly
            // or if updateBoard from server always sets enough rows.
            // But as a fallback, ensure the row exists.
            while (board.length <= currentRow) {
                board.push('');
            }
        }
        board[currentRow] = currentGuess;
        renderBoard(); // Re-render the board with the current partial guess
    }


    function handleGuessSubmit() {
        if (isGameOver) return;

        const guess = textInput.value.trim();
        if (guess.length === WORD_LENGTH) {
            // Before sending, ensure the board is updated with the final current guess
            // This is effectively "locking in" the currentGuess into the board state
            board[currentRow] = guess.toUpperCase();
            socket.emit('guess', { gameId, guess, playerName }); // Send guess and player name
            textInput.value = ''; // Clear input after submission
            currentGuess = ''; // Clear currentGuess after submission
            // We don't increment currentRow here. The server will tell us the new currentRow.
        } else {
            showMessage('Not enough letters!');
        }
    }

    function showMessage(message) {
        const messageElement = messageContainer;
        messageElement.textContent = message;
        messageElement.classList.add('show-message');
        setTimeout(() => {
            messageElement.classList.remove('show-message');
        }, 3000);
    }

    // updateBoard now expects a 1D array of strings
    function updateBoard(newBoard) {
        board = newBoard; // Directly replace the board with the server's state
        // When the server sends an update, it represents the full history of guesses
        // So we need to re-evaluate the currentRow based on the received board
        currentRow = newBoard.length; // The next guess will go to the end of this array
        // We also need to make sure 'board' has enough empty rows for future guesses
        while (board.length < MAX_GUESSES) {
            board.push(''); // Add empty strings for remaining guess slots
        }
        renderBoard();
    }

    function displayGameOver(isWin, word) {
        isGameOver = true;
        gameOverTitle.textContent = isWin ? 'Congratulations!' : 'Game Over!';
        gameOverMessage.textContent = isWin
            ? 'You guessed the word!'
            : `The word was ${word.toUpperCase()}. Better luck next time!`;
        gameOverModal.classList.add('show');
    }

    function resetGame() {
        createBoard(); // Reset board to empty strings
        currentRow = 0;
        currentGuess = '';
        isGameOver = false;
        gameOverModal.classList.remove('show');
        socket.emit('new-game', { gameId, playerName }); // Emit new-game event with playerName
        submittedWords = [];
        wordListElement.innerHTML = '';
        renderBoard(); // Ensure the board is rendered when resetting.
    }

    function updateSubmittedWords(newWord, playerName) {
        submittedWords.push({ word: newWord, player: playerName });
        const li = document.createElement('li');
        li.textContent = `${playerName}: ${newWord.toUpperCase()}`; // Display "Name: Word" in uppercase
        wordListElement.appendChild(li);
        wordListElement.scrollTop = wordListElement.scrollHeight; // Scroll to bottom
    }

    newGameButton.addEventListener('click', resetGame);
    submitButton.addEventListener('click', handleGuessSubmit);
    textInput.addEventListener('input', updateCurrentGuessDisplay); // Listen for input changes

    socket.on('connect', () => {
        playerId = socket.id;
        socket.emit('join-game', { gameId, playerName }); // Send player name on join
    });

    socket.on('game-start', (data) => {
        solutionWord = data.word; // Set the solution word
        createBoard(); // Initialize the board with empty strings
        renderBoard(); // Render the empty board
        if (data.players) {
            players = data.players;
            updatePlayerList(data.players);
        }
        // If there are already guesses (e.g., player joined mid-game), update board
        if (data.board) {
            updateBoard(data.board);
        }
    });

    socket.on('update-board', (data) => {
        if (data && data.board && Array.isArray(data.board)) {
            // Update the board with the server's full state of guesses
            updateBoard(data.board);

            // Logic to add the last submitted word to the submittedWords list
            // The server sends the *entire* board state, so the last guess
            // is the last element in data.board.
            if (data.board.length > 0) {
                const lastGuessedWord = data.board[data.board.length - 1]; // Get the last submitted word
                const emittingPlayerName = data.playerName; // The server needs to send this with the update-board event
                updateSubmittedWords(lastGuessedWord, emittingPlayerName);
            }
        } else {
            console.error("data is undefined, data.board is undefined or not an array:", data);
        }
    });

    socket.on('game-over', (data) => {
        displayGameOver(data.isWin, data.word);
        isGameOver = true;
    });

    socket.on('message', (message) => {
        showMessage(message);
    });

    socket.on('player-list', (updatedPlayers) => {
        players = updatedPlayers;
        updatePlayerList(updatedPlayers);
    });

    function updatePlayerList(playerList) {
        playerListElement.innerHTML = ''; // Clear the list
        playerList.forEach(player => {
            const li = document.createElement('li');
            li.textContent = player.id === playerId ? `You (${player.name})` : `${player.name}`; // Display "You"
            if (player.id === playerId) {
                li.id = "current-player";
            }
            playerListElement.appendChild(li);
        });
    }

    // Initial setup
    createBoard();
    renderBoard();
</script>
</body>
</html>